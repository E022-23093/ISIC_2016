#!/usr/bin/env python3

import argparse, os, glob, multiprocessing, json
import tiledwebmaps as twm
from PIL import Image
Image.MAX_IMAGE_PIXELS = None
import imageio.v2 as imageio
import tinypl as pl
import yaml

parser = argparse.ArgumentParser()
parser.add_argument("--path", type=str, required=True, help="Base path for output")
parser.add_argument("--png_path", type=str, required=True, help="Path to directory containing PNG files")
parser.add_argument("--geojson", type=str, required=True, help="Path to GeoJSON file containing coordinate information")
parser.add_argument("--shape", type=int, default=512, help="Tile size (default 512)")
parser.add_argument("--workers", type=int, default=32)
args = parser.parse_args()

# 创建输出目录
output_path = os.path.join(args.path, "tiles")
if not os.path.exists(output_path):
    os.makedirs(output_path)

# 获取所有PNG文件
png_files = glob.glob(os.path.join(args.png_path, "*.png"))
if not png_files:
    print(f"No PNG files found in {args.png_path}")
    exit(1)

print(f"Found {len(png_files)} PNG files")

# 读取GeoJSON文件
if not os.path.exists(args.geojson):
    print(f"GeoJSON file not found: {args.geojson}")
    exit(1)

with open(args.geojson, 'r', encoding='utf-8') as f:
    geojson_data = json.load(f)

# 创建文件名到坐标的映射
coord_mapping = {}
for feature in geojson_data['features']:
    properties = feature.get('properties', {})
    geometry = feature.get('geometry', {})
    
    # 从properties中获取id作为文件名标识
    if 'id' in properties and geometry.get('type') == 'Point':
        file_id = str(properties['id'])
        coordinates = geometry['coordinates']
        
        # Point坐标格式：[lon, lat]
        lon, lat = coordinates[0], coordinates[1]
        
        # 创建可能的文件名格式
        possible_filenames = [
            f"{file_id}.png",
            f"{file_id}",
            file_id
        ]
        
        for filename in possible_filenames:
            coord_mapping[filename] = [lat, lon]  # [lat, lon] 格式

print(f"Loaded coordinate information for {len(coord_mapping)} points from GeoJSON")

# 计算分区参数
if args.shape == 512:
    partition = 1
    shape = (512, 512)
    tile_shape_crs = [1500.0, 1500.0]  # 这个值可能需要根据你的实际需求调整
else:
    partition = 512 // args.shape
    if partition * args.shape != 512:
        print("--shape must be a divisor of 512")
        exit(1)
    shape = (args.shape, args.shape)
    tile_shape_crs = [1500.0 / partition, 1500.0 / partition]

# 创建layout，直接使用EPSG:4326
layout = twm.Layout(
    crs=twm.proj.CRS("epsg:4326"),
    tile_shape_px=shape,
    tile_shape_crs=tile_shape_crs,
    tile_axes=twm.geo.CompassAxes("east", "north"),
)

# 创建layout配置文件
layout_yaml = {
    "crs": "epsg:4326",
    "tile_shape_px": [shape[0], shape[1]],
    "tile_shape_crs": tile_shape_crs,
    "tile_axes": ["east", "north"],
    "path": "{zoom}/{x}/{y}.jpg",
    "min_zoom": 0,
    "max_zoom": 0,
}
with open(os.path.join(output_path, "layout.yaml"), "w") as f:
    yaml.dump(layout_yaml, f, default_flow_style=False)

print(f"Processing {len(png_files)} PNG files with tile size {args.shape}x{args.shape}")

pipe = png_files
pipe = pl.thread.mutex(pipe)

lock = multiprocessing.Lock()
lock2 = multiprocessing.Lock()

def process(png_file):
    try:
        # 读取PNG图像
        image = imageio.imread(png_file)
        
        # 如果是RGBA，转换为RGB
        if len(image.shape) == 3 and image.shape[-1] == 4:
            image = image[:, :, :3]
        elif len(image.shape) == 2:  # 灰度图
            image = imageio.imread(png_file, pilmode='RGB')
            
        # 从GeoJSON获取坐标信息
        filename = os.path.basename(png_file)
        base_name = os.path.splitext(filename)[0]  # 去掉.png扩展名
        
        if filename in coord_mapping:
            latlon = coord_mapping[filename]
        elif base_name in coord_mapping:
            latlon = coord_mapping[base_name]
        else:
            # 尝试更多匹配方式
            possible_names = [
                filename,
                base_name,
                f"{base_name}.png"
            ]
            
            latlon = None
            for name in possible_names:
                if name in coord_mapping:
                    latlon = coord_mapping[name]
                    break
                    
            if latlon is None:
                print(f"Warning: No coordinate information found for {filename} (base: {base_name}) in GeoJSON")
                print(f"Available IDs sample: {list(coord_mapping.keys())[:5]}...")
                return
            
        # 处理图像并生成瓦片
        for tile_image, tile in twm.util.to_tiles(image, latlon, layout, partition):
            tile_path = os.path.join(output_path, "0", f"{tile[0]}")
            if not os.path.isdir(tile_path):
                with lock2:
                    if not os.path.isdir(tile_path):
                        os.makedirs(tile_path)
            imageio.imwrite(os.path.join(tile_path, f"{tile[1]}.jpg"), tile_image, quality=100)
            
    except Exception as e:
        print(f"Error processing {png_file}: {str(e)}")

pipe = pl.process.map(pipe, process, workers=args.workers)

import tqdm
for _ in tqdm.tqdm(pipe, total=len(png_files), desc="Processing PNG tiles"):
    pass

# 生成多层级瓦片
twm.util.add_zooms(output_path, workers=args.workers)

print("Processing complete!")
